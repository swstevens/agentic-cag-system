---
title: MTG CAG System - Improved Architecture (Proposal)
description: Suggested architectural improvements applying SOLID principles and design patterns
---

classDiagram
    %% ============================================================================
    %% CORE ABSTRACTIONS (NEW - Interface Segregation Principle)
    %% ============================================================================

    class IAgent {
        <<interface>>
        +process(request: AgentRequest)* AgentResponse
        +get_state()* AgentState
        +update_state(status: str, task: str)*
    }

    class ICache {
        <<interface>>
        +get(key: str)* Optional[Any]
        +put(key: str, value: Any)*
        +evict(key: str)*
        +clear()*
        +get_stats()* Dict
    }

    class ICardRepository {
        <<interface>>
        +get_by_name(name: str)* Optional[MTGCard]
        +search(criteria: SearchCriteria)* List[MTGCard]
        +fuzzy_search(name: str, limit: int)* List[MTGCard]
    }

    class IAnalyzer {
        <<interface>>
        +analyze(cards: List[MTGCard], context: AnalysisContext)* AnalysisResult
    }

    class IValidator {
        <<interface>>
        +validate(cards: List[MTGCard], rules: ValidationRules)* ValidationResult
    }

    class IConnectionManager {
        <<interface>>
        +connect()*
        +disconnect()*
        +is_connected()* bool
        +get_session()* Session
    }

    class IDataLoader {
        <<interface>>
        +load_from_source(source: str, format: str)*
    }

    %% ============================================================================
    %% TYPED REQUEST/RESPONSE OBJECTS (NEW - Type Safety)
    %% ============================================================================

    class AgentRequest {
        <<abstract>>
        +request_id: str
        +timestamp: datetime
        +context: Dict[str, Any]
    }

    class SchedulingRequest {
        +query_text: str
        +session_id: str
        +user_context: Dict[str, Any]
    }

    class KnowledgeRequest {
        +card_names: List[str]
        +fuzzy_search: bool
        +format_filter: Optional[str]
    }

    class ReasoningRequest {
        +cards: List[MTGCard]
        +validation_type: str
        +format: Optional[str]
        +deck_archetype: Optional[str]
    }

    class AnalysisRequest {
        +cards: List[MTGCard]
        +archetype: str
        +format: Optional[str]
    }

    class SchedulingResponse {
        +query_type: QueryType
        +extracted_requirements: Dict[str, Any]
        +next_steps: List[str]
        +confidence: float
    }

    class KnowledgeResponse {
        +cards: List[MTGCard]
        +extracted_card_names: List[str]
        +cache_hits: int
        +db_hits: int
        +answer: str
    }

    class ReasoningResponse {
        +is_valid: bool
        +validations: List[ValidationResult]
        +reasoning: List[str]
        +suggestions: List[str]
    }

    class AnalysisResponse {
        +analysis_result: DeckAnalysisResult
        +execution_time: float
    }

    AgentRequest <|-- SchedulingRequest
    AgentRequest <|-- KnowledgeRequest
    AgentRequest <|-- ReasoningRequest
    AgentRequest <|-- AnalysisRequest

    %% ============================================================================
    %% IMPROVED AGENT HIERARCHY (Strategy Pattern + Dependency Inversion)
    %% ============================================================================

    class BaseAgent {
        <<abstract>>
        #agent_id: str
        #agent_type: AgentType
        #state: AgentState
        #metrics_collector: MetricsCollector
        #circuit_breaker: CircuitBreaker
        #retry_policy: RetryPolicy
        +process(request: AgentRequest)* AgentResponse
        +update_state(status: str, task: str)
        +get_state() AgentState
        #execute_with_resilience(fn: Callable) Any
        #record_metrics(operation: str, duration: float, success: bool)
    }

    class SchedulingAgent {
        -model: str
        -intent_classifier: IntentClassifier
        +process(request: SchedulingRequest) AgentResponse
    }

    class KnowledgeFetchAgent {
        -repository: ICardRepository
        -model: str
        +process(request: KnowledgeRequest) AgentResponse
        -_extract_card_names_with_llm(query: str) List[str]
    }

    class SymbolicReasoningAgent {
        -validators: List[IValidator]
        -model: str
        +process(request: ReasoningRequest) AgentResponse
    }

    class DeckAnalyzerAgent {
        -analyzer: IAnalyzer
        -model: str
        +process(request: AnalysisRequest) AgentResponse
    }

    IAgent <|.. BaseAgent
    BaseAgent <|-- SchedulingAgent
    BaseAgent <|-- KnowledgeFetchAgent
    BaseAgent <|-- SymbolicReasoningAgent
    BaseAgent <|-- DeckAnalyzerAgent
    KnowledgeFetchAgent --> ICardRepository
    SymbolicReasoningAgent --> IValidator
    DeckAnalyzerAgent --> IAnalyzer

    %% ============================================================================
    %% REPOSITORY PATTERN (NEW - Abstraction over data access)
    %% ============================================================================

    class CardRepository {
        -cache: ICache
        -database_service: DatabaseService
        +get_by_name(name: str) Optional[MTGCard]
        +search(criteria: SearchCriteria) List[MTGCard]
        +fuzzy_search(name: str, limit: int) List[MTGCard]
        -_get_from_cache(name: str) Optional[MTGCard]
        -_get_from_db(name: str) Optional[MTGCard]
        -_promote_to_cache(card: MTGCard)
    }

    class SearchCriteria {
        +colors: Optional[List[CardColor]]
        +types: Optional[List[CardType]]
        +format: Optional[str]
        +cmc_min: Optional[float]
        +cmc_max: Optional[float]
        +text_query: Optional[str]
        +rarity: Optional[str]
        +limit: int
    }

    class AnalysisContext {
        +archetype: str
        +format: Optional[str]
        +target_deck_size: int
        +metadata: Dict[str, Any]
    }

    class ValidationRules {
        +format: str
        +max_copies: int
        +min_deck_size: int
        +max_deck_size: int
        +allow_basic_lands: bool
    }

    class ValidationResult {
        +is_valid: bool
        +validator_name: str
        +messages: List[str]
        +invalid_cards: List[str]
        +suggestions: List[str]
    }

    class AnalysisResult {
        <<abstract>>
        +analysis_type: str
        +timestamp: datetime
    }

    ICardRepository <|.. CardRepository
    CardRepository --> ICache
    CardRepository --> DatabaseService

    %% ============================================================================
    %% CACHE STRATEGY PATTERN (Unified Interface)
    %% ============================================================================

    class CacheStrategy {
        <<abstract>>
        #max_size: int
        #stats: CacheStats
        +get(key: str)* Optional[Any]
        +put(key: str, value: Any)*
        +evict(key: str)*
        +clear()*
        +get_stats()* CacheStats
    }

    class LRUCacheStrategy {
        -cache: OrderedDict
        -access_counts: Dict[str, int]
        +get(key: str) Optional[Any]
        +put(key: str, value: Any)
        +evict(key: str)
        -_evict_lru()
    }

    class TieredCacheStrategy {
        -l1_cache: ICache
        -l2_cache: ICache
        -l3_cache: ICache
        -promotion_threshold: int
        +get(key: str) Optional[Any]
        +put(key: str, value: Any)
        -_promote_to_l1(key: str, value: Any)
        -_check_promotion(key: str)
    }

    class TTLCacheStrategy {
        -cache: Dict
        -expiry_times: Dict[str, datetime]
        -default_ttl: int
        +get(key: str) Optional[Any]
        +put(key: str, value: Any, ttl: int)
        -_cleanup_expired()
    }

    class CacheStats {
        +hits: int
        +misses: int
        +evictions: int
        +size: int
        +hit_rate: float
    }

    ICache <|.. CacheStrategy
    CacheStrategy <|-- LRUCacheStrategy
    CacheStrategy <|-- TieredCacheStrategy
    CacheStrategy <|-- TTLCacheStrategy
    TieredCacheStrategy o-- ICache
    CacheStrategy *-- CacheStats

    %% ============================================================================
    %% ANALYZER STRATEGY PATTERN (Replaces dual analyzer problem)
    %% ============================================================================

    class DeckAnalyzer {
        <<abstract>>
        +analyze(cards: List[MTGCard], context: AnalysisContext)* DeckAnalysisResult
    }

    class RuleBasedAnalyzer {
        -card_repository: ICardRepository
        +analyze(cards: List[MTGCard], context: AnalysisContext) DeckAnalysisResult
        -_analyze_mana_curve(cards: List[MTGCard]) ManaCurveAnalysis
        -_analyze_land_ratio(cards: List[MTGCard]) LandRatioAnalysis
        -_detect_basic_synergies(cards: List[MTGCard]) List[SynergyDetection]
    }

    class LLMBasedAnalyzer {
        -model: str
        -prompt_builder: PromptBuilder
        +analyze(cards: List[MTGCard], context: AnalysisContext) DeckAnalysisResult
        -_format_cards_for_llm(cards: List[MTGCard]) str
    }

    class CompositeAnalyzer {
        -analyzers: List[IAnalyzer]
        -merge_strategy: AnalysisMergeStrategy
        +analyze(cards: List[MTGCard], context: AnalysisContext) DeckAnalysisResult
        +add_analyzer(analyzer: IAnalyzer)
        -_merge_results(results: List[DeckAnalysisResult]) DeckAnalysisResult
    }

    class AnalysisMergeStrategy {
        <<enumeration>>
        PREFER_LLM
        PREFER_RULES
        AVERAGE
        WEIGHTED
    }

    IAnalyzer <|.. DeckAnalyzer
    DeckAnalyzer <|-- RuleBasedAnalyzer
    DeckAnalyzer <|-- LLMBasedAnalyzer
    DeckAnalyzer <|-- CompositeAnalyzer
    CompositeAnalyzer o-- IAnalyzer
    CompositeAnalyzer --> AnalysisMergeStrategy
    RuleBasedAnalyzer --> ICardRepository

    %% ============================================================================
    %% VALIDATOR PIPELINE (Single Responsibility)
    %% ============================================================================

    class DeckValidator {
        <<abstract>>
        +validate(cards: List[MTGCard], rules: ValidationRules)* ValidationResult
    }

    class FormatLegalityValidator {
        +validate(cards: List[MTGCard], rules: ValidationRules) ValidationResult
    }

    class CardLimitValidator {
        +validate(cards: List[MTGCard], rules: ValidationRules) ValidationResult
    }

    class ManaCurveValidator {
        -optimal_curves: Dict[str, Dict]
        +validate(cards: List[MTGCard], rules: ValidationRules) ValidationResult
    }

    class DeckSizeValidator {
        +validate(cards: List[MTGCard], rules: ValidationRules) ValidationResult
    }

    class ValidationPipeline {
        -validators: List[IValidator]
        -stop_on_failure: bool
        +validate(cards: List[MTGCard], rules: ValidationRules) ValidationResult
        +add_validator(validator: IValidator) Self
        +remove_validator(validator: IValidator) Self
        -_aggregate_results(results: List[ValidationResult]) ValidationResult
    }

    IValidator <|.. DeckValidator
    DeckValidator <|-- FormatLegalityValidator
    DeckValidator <|-- CardLimitValidator
    DeckValidator <|-- ManaCurveValidator
    DeckValidator <|-- DeckSizeValidator
    IValidator <|.. ValidationPipeline
    ValidationPipeline o-- IValidator

    %% ============================================================================
    %% CHAIN OF RESPONSIBILITY (Replaces monolithic orchestrator)
    %% ============================================================================

    class AgentPipeline {
        -stages: List[PipelineStage]
        -context: PipelineContext
        +add_stage(stage: PipelineStage) Self
        +remove_stage(stage_id: str) Self
        +execute(query: UserQuery) FusedResponse
        -_build_context(query: UserQuery) PipelineContext
    }

    class PipelineStage {
        -stage_id: str
        -agent: IAgent
        -next_stage: Optional[PipelineStage]
        -condition: Callable[[PipelineContext], bool]
        -required: bool
        +handle(context: PipelineContext) Optional[AgentResponse]
        +set_next(stage: PipelineStage) Self
        +should_execute(context: PipelineContext) bool
    }

    class PipelineContext {
        +query: UserQuery
        +intermediate_results: Dict[str, AgentResponse]
        +metadata: Dict[str, Any]
        +timestamp: datetime
        +get_result(agent_type: str) Optional[AgentResponse]
        +add_result(agent_type: str, response: AgentResponse)
    }

    AgentPipeline o-- PipelineStage
    AgentPipeline *-- PipelineContext
    PipelineStage --> IAgent
    PipelineStage --> PipelineStage : next

    %% ============================================================================
    %% FACTORY PATTERN (Centralized Object Creation)
    %% ============================================================================

    class AgentFactory {
        -settings: Settings
        -cache_factory: CacheFactory
        -repository_factory: RepositoryFactory
        +create_agent(agent_type: AgentType, config: AgentConfig) IAgent
        +create_scheduling_agent() SchedulingAgent
        +create_knowledge_agent() KnowledgeFetchAgent
        +create_symbolic_agent() SymbolicReasoningAgent
        +create_analyzer_agent() DeckAnalyzerAgent
        -_build_dependencies(agent_type: AgentType) Dict
    }

    class CacheFactory {
        -settings: Settings
        +create_cache(strategy: str, config: CacheConfig) ICache
        +create_lru_cache(max_size: int) LRUCacheStrategy
        +create_tiered_cache(l1_size: int, l2_size: int, l3_size: int) TieredCacheStrategy
        +create_ttl_cache(max_size: int, ttl: int) TTLCacheStrategy
    }

    class RepositoryFactory {
        -cache_factory: CacheFactory
        +create_repository(cache_strategy: str) ICardRepository
        +create_card_repository(cache: ICache) CardRepository
    }

    class ValidatorFactory {
        +create_validator(validator_type: str) IValidator
        +create_validation_pipeline(validators: List[str]) ValidationPipeline
    }

    class AnalyzerFactory {
        -settings: Settings
        +create_analyzer(analyzer_type: str) IAnalyzer
        +create_composite_analyzer(strategy: AnalysisMergeStrategy) CompositeAnalyzer
    }

    AgentFactory --> AgentType
    AgentFactory --> IAgent
    AgentFactory --> CacheFactory
    AgentFactory --> RepositoryFactory
    CacheFactory --> ICache
    RepositoryFactory --> ICardRepository
    ValidatorFactory --> IValidator
    AnalyzerFactory --> IAnalyzer

    %% ============================================================================
    %% RESILIENCE PATTERNS (Circuit Breaker, Retry, Fallback)
    %% ============================================================================

    class CircuitBreaker {
        -failure_threshold: int
        -timeout_duration: int
        -state: CircuitState
        -failure_count: int
        -last_failure_time: Optional[datetime]
        +call(fn: Callable[[], T]) T
        +reset()
        +get_state() CircuitState
        -_record_success()
        -_record_failure()
        -_should_attempt_reset() bool
    }

    class CircuitState {
        <<enumeration>>
        CLOSED
        OPEN
        HALF_OPEN
    }

    class RetryPolicy {
        -max_retries: int
        -backoff_strategy: BackoffStrategy
        -retryable_exceptions: List[Type[Exception]]
        +execute(fn: Callable[[], T], *args, **kwargs) T
        -_calculate_delay(attempt: int) float
    }

    class BackoffStrategy {
        <<enumeration>>
        LINEAR
        EXPONENTIAL
        FIBONACCI
        CONSTANT
    }

    class FallbackHandler {
        -fallback_fn: Callable
        +execute_with_fallback(primary_fn: Callable, *args, **kwargs) Any
    }

    CircuitBreaker --> CircuitState
    RetryPolicy --> BackoffStrategy
    BaseAgent --> CircuitBreaker
    BaseAgent --> RetryPolicy
    BaseAgent --> FallbackHandler

    %% ============================================================================
    %% OBSERVABILITY (Metrics, Events, Monitoring)
    %% ============================================================================

    class MetricsCollector {
        -metrics: Dict[str, Metric]
        +record_latency(operation: str, duration: float)
        +record_success(operation: str)
        +record_failure(operation: str, error: Exception)
        +increment_counter(name: str)
        +get_metrics() Dict[str, Any]
        +get_metric(name: str) Optional[Metric]
    }

    class Metric {
        +name: str
        +value: float
        +timestamp: datetime
        +tags: Dict[str, str]
    }

    class EventBus {
        -subscribers: Dict[str, List[EventHandler]]
        +publish(event: SystemEvent)
        +subscribe(event_type: str, handler: EventHandler)
        +unsubscribe(event_type: str, handler: EventHandler)
        -_notify_subscribers(event: SystemEvent)
    }

    class EventHandler {
        <<interface>>
        +handle(event: SystemEvent)*
    }

    class SystemEvent {
        <<abstract>>
        +event_id: str
        +timestamp: datetime
        +source: str
        +metadata: Dict[str, Any]
    }

    class AgentExecutionEvent {
        +agent_type: AgentType
        +request_id: str
        +duration: float
        +success: bool
        +error: Optional[str]
    }

    class CacheHitEvent {
        +cache_name: str
        +cache_tier: str
        +key: str
    }

    class CacheMissEvent {
        +cache_name: str
        +cache_tier: str
        +key: str
    }

    class ValidationFailureEvent {
        +validator_name: str
        +failure_reason: str
        +card_names: List[str]
    }

    MetricsCollector *-- Metric
    EventBus o-- EventHandler
    SystemEvent <|-- AgentExecutionEvent
    SystemEvent <|-- CacheHitEvent
    SystemEvent <|-- CacheMissEvent
    SystemEvent <|-- ValidationFailureEvent
    BaseAgent --> MetricsCollector
    BaseAgent --> EventBus
    CacheStrategy --> EventBus
    DeckValidator --> EventBus

    %% ============================================================================
    %% IMPROVED ORCHESTRATOR (Simplified, Delegated Responsibilities)
    %% ============================================================================

    class ImprovedOrchestrator {
        -pipeline: AgentPipeline
        -event_bus: EventBus
        -metrics_collector: MetricsCollector
        -circuit_breaker: CircuitBreaker
        -fallback_handler: FallbackHandler
        +process_query(query: UserQuery) FusedResponse
        +process_with_retry(query: UserQuery, max_retries: int) FusedResponse
        +process_with_fallback(query: UserQuery) FusedResponse
        -_execute_pipeline(query: UserQuery) FusedResponse
        -_fuse_results(context: PipelineContext) FusedResponse
        -_handle_failure(error: Exception, query: UserQuery) FusedResponse
    }

    ImprovedOrchestrator --> AgentPipeline
    ImprovedOrchestrator --> EventBus
    ImprovedOrchestrator --> MetricsCollector
    ImprovedOrchestrator --> CircuitBreaker
    ImprovedOrchestrator --> FallbackHandler

    %% ============================================================================
    %% IMPROVED DECK BUILDING SERVICE (Reduced Coupling)
    %% ============================================================================

    class DeckBuildingService {
        -repository: ICardRepository
        -analyzer: IAnalyzer
        -validator: IValidator
        -strategy: DeckBuildingStrategy
        -event_bus: EventBus
        +build_deck(requirements: DeckRequirements) Deck
        -_execute_build_iteration(requirements: DeckRequirements, current_deck: Deck) Deck
    }

    class DeckBuildingStrategy {
        <<abstract>>
        +select_cards(pool: List[MTGCard], requirements: DeckRequirements, current_deck: Deck)* List[MTGCard]
        +distribute_lands(colors: List[CardColor], count: int)* List[MTGCard]
    }

    class IterativeBuildingStrategy {
        -max_iterations: int
        +select_cards(pool: List[MTGCard], requirements: DeckRequirements, current_deck: Deck) List[MTGCard]
        +distribute_lands(colors: List[CardColor], count: int) List[MTGCard]
        -_score_card_for_archetype(card: MTGCard, archetype: str) float
    }

    class GreedyBuildingStrategy {
        +select_cards(pool: List[MTGCard], requirements: DeckRequirements, current_deck: Deck) List[MTGCard]
        +distribute_lands(colors: List[CardColor], count: int) List[MTGCard]
    }

    class DeckRequirements {
        +format: str
        +colors: List[CardColor]
        +archetype: str
        +deck_size: int
        +strategy_keywords: List[str]
    }

    class Deck {
        +cards: List[MTGCard]
        +format: str
        +archetype: str
        +size: int
        +is_complete() bool
        +add_card(card: MTGCard)
        +remove_card(card_name: str)
    }

    DeckBuildingService --> ICardRepository
    DeckBuildingService --> IAnalyzer
    DeckBuildingService --> IValidator
    DeckBuildingService --> DeckBuildingStrategy
    DeckBuildingService --> EventBus
    DeckBuildingStrategy <|-- IterativeBuildingStrategy
    DeckBuildingStrategy <|-- GreedyBuildingStrategy
    DeckBuildingService ..> DeckRequirements
    DeckBuildingService ..> Deck

    %% ============================================================================
    %% DATABASE LAYER (Interface Segregation)
    %% ============================================================================

    class ConnectionManager {
        -engine: Engine
        -session_factory: sessionmaker
        -db_path: str
        +connect()
        +disconnect()
        +is_connected() bool
        +get_session() Session
    }

    class MTGJsonLoader {
        -connection_manager: IConnectionManager
        +load_from_source(file_path: str)
        -_parse_json_file(file_path: str) List[Dict]
        -_batch_insert(cards_data: List[Dict], batch_size: int)
    }

    class DatabaseService {
        -connection_manager: IConnectionManager
        -query_builder: QueryBuilder
        +execute_query(query: Query) List[CardORM]
        +get_card_by_name(name: str) Optional[CardORM]
        +search_cards_by_criteria(criteria: SearchCriteria) List[CardORM]
        +fuzzy_search(name: str, limit: int) List[CardORM]
    }

    class QueryBuilder {
        +build_search_query(criteria: SearchCriteria) Query
        +build_fuzzy_query(name: str) Query
        +build_format_query(format: str) Query
    }

    IConnectionManager <|.. ConnectionManager
    IDataLoader <|.. MTGJsonLoader
    MTGJsonLoader --> IConnectionManager
    DatabaseService --> IConnectionManager
    DatabaseService --> QueryBuilder
    CardRepository --> DatabaseService

    %% ============================================================================
    %% EXISTING PYDANTIC MODELS (Preserved from current implementation)
    %% ============================================================================

    class MTGCard {
        +id: str
        +name: str
        +mana_cost: Optional[str]
        +cmc: float
        +colors: List[CardColor]
        +color_identity: List[CardColor]
        +type_line: str
        +types: List[CardType]
        +subtypes: List[str]
        +oracle_text: Optional[str]
        +power: Optional[str]
        +toughness: Optional[str]
        +loyalty: Optional[str]
        +set_code: str
        +rarity: str
        +legalities: Dict[str, str]
        +keywords: List[str]
    }

    class CardORM {
        +id: str
        +name: str
        +mana_cost: Optional[str]
        +cmc: float
        +colors: str
        +color_identity: str
        +type_line: str
        +types: str
        +subtypes: str
        +oracle_text: Optional[str]
        +power: Optional[str]
        +toughness: Optional[str]
        +loyalty: Optional[str]
        +set_code: str
        +rarity: str
        +legalities: str
        +keywords: str
        +to_dict() dict
    }

    class CardColor {
        <<enumeration>>
        WHITE
        BLUE
        BLACK
        RED
        GREEN
        COLORLESS
    }

    class CardType {
        <<enumeration>>
        CREATURE
        INSTANT
        SORCERY
        ENCHANTMENT
        ARTIFACT
        PLANESWALKER
        LAND
        BATTLE
    }

    class CardCollection {
        +cards: List[MTGCard]
        +total_count: int
        +format_filter: Optional[str]
        +metadata: Dict[str, Any]
        +cached_at: datetime
        +to_context_string() str
    }

    class AgentType {
        <<enumeration>>
        SCHEDULING
        KNOWLEDGE_FETCH
        SYMBOLIC_REASONING
    }

    class AgentState {
        +agent_id: str
        +agent_type: AgentType
        +current_task: Optional[str]
        +status: str
        +working_memory: Dict[str, Any]
        +metrics: Dict[str, float]
    }

    class QueryType {
        <<enumeration>>
        DECK_BUILDING
        CARD_SEARCH
        RULES_QUESTION
        CARD_INTERACTION
        FORMAT_LEGALITY
        COMBO_QUERY
    }

    class QueryIntent {
        +primary_intent: QueryType
        +entities: List[str]
        +constraints: Dict[str, Any]
        +requires_symbolic_reasoning: bool
        +requires_knowledge_fetch: bool
        +temporal_context: Optional[str]
    }

    class UserQuery {
        +query_id: str
        +session_id: str
        +query_text: str
        +context: Dict[str, Any]
        +timestamp: datetime
        +intent: Optional[QueryIntent]
    }

    class AgentResponse {
        +agent_type: str
        +success: bool
        +data: Dict[str, Any]
        +confidence: float
        +reasoning_trace: List[str]
        +error: Optional[str]
    }

    class ReasoningStep {
        +step_id: str
        +agent_type: AgentType
        +action: str
        +input_data: Dict[str, Any]
        +output_data: Dict[str, Any]
        +confidence: float
        +timestamp: datetime
    }

    class ReasoningChain {
        +query_id: str
        +steps: List[ReasoningStep]
        +final_result: Optional[Dict[str, Any]]
        +total_confidence: float
        +add_step(step: ReasoningStep)
    }

    class FusedResponse {
        +query_id: str
        +session_id: str
        +answer: str
        +confidence: float
        +sources: List[str]
        +agent_contributions: Dict[str, AgentResponse]
        +reasoning_chain: Optional[List[Dict[str, Any]]]
        +metadata: Dict[str, Any]
        +timestamp: datetime
    }

    class DeckAnalysisResult {
        +overall_score: float
        +overall_assessment: str
        +mana_curve: ManaCurveAnalysis
        +land_ratio: LandRatioAnalysis
        +synergies: List[SynergyDetection]
        +win_conditions: WinConditionAnalysis
        +archetype_consistency: ArchetypeConsistency
        +strengths: DeckStrengths
        +weaknesses: DeckWeaknesses
        +priority_improvements: List[str]
        +is_competitive: bool
        +needs_major_changes: bool
    }

    class ManaCurveAnalysis {
        +average_cmc: float
        +curve_quality: CurveQuality
        +curve_distribution: Dict[str, int]
        +focus_percentage: float
        +recommendations: List[str]
    }

    class CurveQuality {
        <<enumeration>>
        EXCELLENT
        GOOD
        ACCEPTABLE
        TOO_LOW
        TOO_HIGH
        POOR
    }

    class LandRatioAnalysis {
        +land_count: int
        +land_percentage: float
        +ratio_quality: LandRatioQuality
        +recommended_land_count: Optional[int]
        +recommendations: List[str]
    }

    class LandRatioQuality {
        <<enumeration>>
        EXCELLENT
        GOOD
        TOO_FEW
        TOO_MANY
    }

    class SynergyDetection {
        +name: str
        +card_names: List[str]
        +description: str
        +strength: Literal["weak", "moderate", "strong", "game-winning"]
    }

    class WinConditionAnalysis {
        +primary_win_conditions: List[str]
        +backup_win_conditions: List[str]
        +win_condition_quality: Literal["none", "weak", "acceptable", "good", "excellent"]
        +recommendations: List[str]
    }

    class ArchetypeConsistency {
        +declared_archetype: str
        +consistency_score: float
        +archetype_strengths: List[str]
        +archetype_weaknesses: List[str]
        +recommendations: List[str]
    }

    class DeckStrengths {
        +strong_matchups: List[str]
        +key_cards: List[str]
        +unique_advantages: List[str]
    }

    class DeckWeaknesses {
        +weak_matchups: List[str]
        +vulnerabilities: List[str]
        +missing_elements: List[str]
    }

    MTGCard "1" *-- "many" CardColor
    MTGCard "1" *-- "many" CardType
    CardCollection "1" *-- "many" MTGCard
    BaseAgent "1" *-- "1" AgentState
    BaseAgent "1" *-- "1" AgentType
    UserQuery "1" *-- "1" QueryIntent
    QueryIntent "1" *-- "1" QueryType
    ReasoningChain "1" *-- "many" ReasoningStep
    ReasoningStep "1" *-- "1" AgentType
    FusedResponse "1" *-- "many" AgentResponse
    DeckAnalysisResult "1" *-- "1" ManaCurveAnalysis
    DeckAnalysisResult "1" *-- "1" LandRatioAnalysis
    DeckAnalysisResult "1" *-- "many" SynergyDetection
    DeckAnalysisResult "1" *-- "1" WinConditionAnalysis
    DeckAnalysisResult "1" *-- "1" ArchetypeConsistency
    DeckAnalysisResult "1" *-- "1" DeckStrengths
    DeckAnalysisResult "1" *-- "1" DeckWeaknesses
    ManaCurveAnalysis --> CurveQuality
    LandRatioAnalysis --> LandRatioQuality
    DatabaseService ..> CardORM
    CardORM ..> MTGCard : converts to
    ImprovedOrchestrator ..> UserQuery
    ImprovedOrchestrator ..> FusedResponse
    DeckAnalyzer ..> DeckAnalysisResult
    AnalysisResponse --> DeckAnalysisResult

    %% ============================================================================
    %% CONFIGURATION (Enhanced with Validation)
    %% ============================================================================

    class Settings {
        +app_name: str
        +version: str
        +debug: bool
        +agent_configs: Dict[AgentType, AgentConfig]
        +cache_config: CacheConfig
        +database_config: DatabaseConfig
        +resilience_config: ResilienceConfig
        +validate() bool
        +get_agent_config(agent_type: AgentType) AgentConfig
    }

    class AgentConfig {
        +model: str
        +timeout: int
        +max_retries: int
        +circuit_breaker_threshold: int
        +enable_metrics: bool
    }

    class CacheConfig {
        +strategy: str
        +l1_max_size: int
        +l2_max_size: int
        +l3_max_size: int
        +default_ttl: int
        +enable_stats: bool
    }

    class DatabaseConfig {
        +db_path: str
        +pool_size: int
        +echo: bool
        +mtgjson_path: str
    }

    class ResilienceConfig {
        +enable_circuit_breaker: bool
        +enable_retry: bool
        +max_retries: int
        +timeout: int
        +backoff_strategy: BackoffStrategy
    }

    Settings o-- AgentConfig
    Settings o-- CacheConfig
    Settings o-- DatabaseConfig
    Settings o-- ResilienceConfig
    ResilienceConfig --> BackoffStrategy

    %% ============================================================================
    %% NOTES ON IMPROVEMENTS
    %% ============================================================================

    note for IAgent "Interface Segregation:\nAll agents implement\nthe same contract"

    note for ICardRepository "Repository Pattern:\nAbstracts data access,\nenables testing with mocks"

    note for AgentPipeline "Chain of Responsibility:\nAgents process in sequence,\neach can pass to next"

    note for CompositeAnalyzer "Composite Pattern:\nCombines rule-based and LLM analyzers,\nsolves dual analyzer problem"

    note for ValidationPipeline "Pipeline Pattern:\nValidators run in sequence,\nall must pass or aggregate"

    note for CircuitBreaker "Resilience Pattern:\nPrevents cascading failures\nfrom external LLM services"

    note for EventBus "Observer Pattern:\nDecoupled communication\nbetween components"

    note for AgentFactory "Factory Pattern:\nCentralized agent creation\nwith dependency injection"

    note for TieredCacheStrategy "Strategy Pattern:\nInterchangeable caching\nstrategies"

    note for DeckBuildingStrategy "Strategy Pattern:\nMultiple deck building\napproaches, easy to A/B test"

    note for SchedulingRequest "Type Safety:\nReplaces Dict[str, Any]\nwith typed requests"

    note for ImprovedOrchestrator "Simplified Orchestrator:\nDelegates to pipeline,\nfocuses on coordination"
