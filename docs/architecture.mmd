---
title: MTG CAG System - Architecture Diagram
---

classDiagram
    %% ============================================================================
    %% BASE AGENT HIERARCHY
    %% ============================================================================
    class IAgent {
        <<interface>>
        +process(request: Any)* AgentResponse
        +get_state()* AgentState
        +update_state(status: str, task: str)*
    }

    class BaseAgent {
        <<abstract>>
        #agent_id: str
        #agent_type: AgentType
        #state: AgentState
        +process(request: Any)* AgentResponse
        +update_state(status: str, task: str)
        +get_state() AgentState
    }

    IAgent <|.. BaseAgent

    class SchedulingAgent {
        -model: str
        -api_key: str
        +process(request: Any) AgentResponse
        -_extract_requirements(query: str) Dict
        -_classify_query_type(query: str) QueryType
    }

    class KnowledgeFetchAgent {
        -repository: ICardRepository
        -model: str
        -api_key: str
        +process(request: Any) AgentResponse
        -_extract_card_names_with_llm(query: str) List[str]
        -_lookup_cards(card_names: List[str]) List[MTGCard]
    }

    class SymbolicReasoningAgent {
        -validators: List[IValidator]
        -model: str
        -api_key: str
        +process(request: Any) AgentResponse
        -_validate_deck_legality(cards: List[MTGCard]) bool
        -_analyze_mana_curve(cards: List[MTGCard]) Dict
        -_check_card_interactions(cards: List[MTGCard]) List[str]
    }

    BaseAgent <|-- SchedulingAgent
    BaseAgent <|-- KnowledgeFetchAgent
    BaseAgent <|-- SymbolicReasoningAgent

    %% ============================================================================
    %% CORE ABSTRACTIONS (Interface Segregation)
    %% ============================================================================
    class ICache {
        <<interface>>
        +get(key: str)* Optional[Any]
        +set(key: str, value: Any)* void
        +evict(key: str)*
        +clear()*
        +get_stats()* Dict
    }

    class ICardRepository {
        <<interface>>
        +get_by_name(name: str)* Optional[MTGCard]
        +search(criteria: SearchCriteria)* List[MTGCard]
        +fuzzy_search(name: str, limit: int)* List[MTGCard]
    }

    class IAnalyzer {
        <<interface>>
        +analyze(cards: List[MTGCard], context: AnalysisContext)* AnalysisResult
    }

    class IValidator {
        <<interface>>
        +validate(cards: List[MTGCard], rules: ValidationRules)* ValidationResult
    }

    class IConnectionManager {
        <<interface>>
        +connect()*
        +disconnect()*
        +is_connected()* bool
        +get_session()* Session
    }

    %% ============================================================================
    %% SERVICE LAYER
    %% ============================================================================
    class DatabaseService {
        -engine: Engine
        -session_factory: sessionmaker
        -db_path: str
        +connect()
        +disconnect()
        +get_card_by_name(name: str) Optional[MTGCard]
        +search_cards(filters: Dict) List[MTGCard]
        +fuzzy_search(name: str, limit: int) List[MTGCard]
        +load_from_mtgjson(file_path: str)
        -_create_tables()
        -_create_fts_index()
    }

    class MultiTierCache {
        -l1_cache: Dict
        -l2_cache: Dict
        -l3_cache: Dict
        -l1_max: int
        -l2_max: int
        -l3_max: int
        +get(key: str, tier: str) Optional[Any]
        +set(key: str, value: Any, tier: str, ttl: int)
        +get_stats() Dict
        -_promote_to_l1(key: str)
        -_evict_from_tier(tier: str)
    }

    class CardRepository {
        -cache: ICache
        -database_service: DatabaseService
        +get_by_name(name: str) Optional[MTGCard]
        +search(criteria: SearchCriteria) List[MTGCard]
        +fuzzy_search(name: str, limit: int) List[MTGCard]
        +preload_by_names(names: List[str])
        -_get_from_cache(name: str) Optional[MTGCard]
        -_get_from_db(name: str) Optional[MTGCard]
        -_promote_to_cache(card: MTGCard)
    }

    class DeckBuilderServiceV2 {
        -repository: ICardRepository
        -analyzer: IAnalyzer
        -validator: Optional[IValidator]
        -max_iterations: int
        -vector_store: Optional[VectorStoreService]
        +build_deck(requirements: DeckRequirements) Deck
        -_execute_build_iteration(requirements: DeckRequirements, deck: Deck) Deck
        -_select_cards_for_archetype(pool: List[MTGCard], archetype: str) List[MTGCard]
        -_distribute_lands_by_color(colors: List, count: int) List[MTGCard]
        -_score_card(card: MTGCard, archetype: str) float
    }

    class PatternSynergyService {
        -patterns: Dict[str, List[str]]
        -pattern_complements: Dict[str, List[str]]
        -synergy_scores: Dict[Tuple, float]
        +find_synergies(card_name: str, max_results: int, legal_cards: List) List[Dict]
        -_calculate_synergy_score(pattern1: str, pattern2: str) float
    }

    class SynergyLookupService {
        -pattern_synergy: PatternSynergyService
        -card_lookup: CardLookupService
        +lookup_synergies(card_name: str, max_results: int, format_filter: str) SynergyLookupResponse
        -_apply_format_filter(synergies: List, format_filter: str) List
    }

    class VectorStoreService {
        -collection: ChromaDB Collection
        -embedding_function: SentenceTransformer
        +find_similar_cards(card_name: str, n_results: int) List[Dict]
        +find_cards_by_concept(concept: str, n_results: int) List[Dict]
        +build_embeddings(database_service: DatabaseService)
        +is_initialized() bool
    }

    class DeckRequirements {
        +format: str
        +colors: List[CardColor]
        +archetype: str
        +deck_size: int
        +strategy_keywords: List[str]
    }

    class Deck {
        +cards: List[MTGCard]
        +format: str
        +archetype: str
        +size: int
        +is_complete() bool
        +add_card(card: MTGCard)
        +remove_card(card_name: str)
    }

    class SearchCriteria {
        +colors: Optional[List[CardColor]]
        +types: Optional[List[CardType]]
        +format: Optional[str]
        +cmc_min: Optional[float]
        +cmc_max: Optional[float]
        +text_query: Optional[str]
        +rarity: Optional[str]
        +limit: int
    }

    class AnalysisContext {
        +archetype: str
        +format: Optional[str]
        +target_deck_size: int
        +metadata: Dict[str, Any]
    }

    class ValidationRules {
        +format: str
        +max_copies: int
        +min_deck_size: int
        +max_deck_size: int
        +allow_basic_lands: bool
    }

    class ValidationResult {
        +is_valid: bool
        +validator_name: str
        +messages: List[str]
        +invalid_cards: List[str]
        +suggestions: List[str]
    }

    ICache <|.. MultiTierCache
    ICardRepository <|.. CardRepository
    CardRepository o-- ICache
    CardRepository o-- DatabaseService
    KnowledgeFetchAgent --> ICardRepository
    DeckBuilderServiceV2 --> ICardRepository
    DeckBuilderServiceV2 --> IAnalyzer
    DeckBuilderServiceV2 --> IValidator
    DeckBuilderServiceV2 ..> DeckRequirements
    DeckBuilderServiceV2 ..> Deck

    %% ============================================================================
    %% ORCHESTRATION LAYER
    %% ============================================================================
    class AgentOrchestratorV2 {
        -scheduling_agent: IAgent
        -knowledge_agent: IAgent
        -symbolic_agent: IAgent
        -cache: ICache
        -deck_builder: DeckBuilderServiceV2
        +process_query(query: UserQuery) FusedResponse
        -_handle_deck_building(query: UserQuery) Tuple[str, float]
        -_handle_card_lookup(query: UserQuery) Tuple[str, float]
        -_fuse_results(responses: Dict) FusedResponse
    }

    AgentOrchestratorV2 o-- IAgent
    AgentOrchestratorV2 o-- ICache
    AgentOrchestratorV2 o-- DeckBuilderServiceV2
    PatternSynergyService --> CardRepository
    SynergyLookupService --> PatternSynergyService
    SynergyLookupService --> CardRepository

    %% ============================================================================
    %% DATA MODELS
    %% ============================================================================
    class MTGCard {
        +id: str
        +name: str
        +mana_cost: Optional[str]
        +cmc: float
        +colors: List[CardColor]
        +color_identity: List[CardColor]
        +type_line: str
        +types: List[CardType]
        +subtypes: List[str]
        +oracle_text: Optional[str]
        +power: Optional[str]
        +toughness: Optional[str]
        +loyalty: Optional[str]
        +set_code: str
        +rarity: str
        +legalities: Dict[str, str]
        +keywords: List[str]
    }

    class CardORM {
        +id: str
        +name: str
        +mana_cost: Optional[str]
        +cmc: float
        +colors: str
        +color_identity: str
        +type_line: str
        +types: str
        +subtypes: str
        +oracle_text: Optional[str]
        +power: Optional[str]
        +toughness: Optional[str]
        +loyalty: Optional[str]
        +set_code: str
        +rarity: str
        +legalities: str
        +keywords: str
    }

    class CardColor {
        <<enumeration>>
        WHITE
        BLUE
        BLACK
        RED
        GREEN
        COLORLESS
    }

    class CardType {
        <<enumeration>>
        CREATURE
        INSTANT
        SORCERY
        ENCHANTMENT
        ARTIFACT
        PLANESWALKER
        LAND
        TRIBAL
        BATTLE
    }

    class AgentType {
        <<enumeration>>
        SCHEDULING
        KNOWLEDGE_FETCH
        SYMBOLIC_REASONING
        DECK_ANALYZER
    }

    class AgentState {
        +agent_id: str
        +agent_type: AgentType
        +current_task: Optional[str]
        +status: str
        +working_memory: Dict[str, Any]
        +metrics: Dict[str, float]
    }

    class QueryType {
        <<enumeration>>
        DECK_BUILDING
        CARD_SEARCH
        RULES_QUESTION
        CARD_INTERACTION
        FORMAT_LEGALITY
        COMBO_QUERY
    }

    class QueryIntent {
        +primary_intent: QueryType
        +entities: List[str]
        +constraints: Dict[str, Any]
        +requires_symbolic_reasoning: bool
        +requires_knowledge_fetch: bool
        +temporal_context: Optional[str]
    }

    class UserQuery {
        +query_id: str
        +session_id: str
        +query_text: str
        +context: Dict[str, Any]
        +timestamp: datetime
        +intent: Optional[QueryIntent]
    }

    class AgentResponse {
        +agent_type: str
        +success: bool
        +data: Dict[str, Any]
        +confidence: float
        +reasoning_trace: List[str]
        +error: Optional[str]
    }

    class ReasoningStep {
        +step_id: str
        +agent_type: AgentType
        +action: str
        +input_data: Dict
        +output_data: Dict
        +confidence: float
        +timestamp: datetime
    }

    class ReasoningChain {
        +query_id: str
        +steps: List[ReasoningStep]
        +final_result: Optional[Dict]
        +total_confidence: float
    }

    class FusedResponse {
        +query_id: str
        +session_id: str
        +answer: str
        +confidence: float
        +sources: List[str]
        +agent_contributions: Dict[str, AgentResponse]
        +reasoning_chain: Optional[List[Dict]]
        +metadata: Dict[str, Any]
        +timestamp: datetime
    }

    class DeckAnalysisResult {
        +overall_score: float
        +overall_assessment: str
        +mana_curve: ManaCurveAnalysis
        +land_ratio: LandRatioAnalysis
        +synergies: List[SynergyDetection]
        +win_conditions: WinConditionAnalysis
        +archetype_consistency: ArchetypeConsistency
        +strengths: DeckStrengths
        +weaknesses: DeckWeaknesses
        +priority_improvements: List[str]
        +is_competitive: bool
        +needs_major_changes: bool
    }

    class ManaCurveAnalysis {
        +average_cmc: float
        +curve_quality: str
        +curve_distribution: Dict[str, int]
        +focus_percentage: float
        +recommendations: List[str]
    }

    class LandRatioAnalysis {
        +land_count: int
        +land_percentage: float
        +ratio_quality: str
        +recommended_land_count: Optional[int]
        +recommendations: List[str]
    }

    class SynergyDetection {
        +name: str
        +card_names: List[str]
        +description: str
        +strength: str
    }

    class WinConditionAnalysis {
        +primary_win_conditions: List[str]
        +backup_win_conditions: List[str]
        +win_condition_clarity: str
        +recommendations: List[str]
    }

    class ArchetypeConsistency {
        +declared_archetype: str
        +consistency_score: float
        +archetype_strengths: List[str]
        +archetype_weaknesses: List[str]
        +recommendations: List[str]
    }

    class DeckStrengths {
        +strengths: List[str]
    }

    class DeckWeaknesses {
        +weaknesses: List[str]
    }

    class CardCollection {
        +cards: List[MTGCard]
        +total_count: int
        +format_filter: Optional[str]
        +metadata: Dict
        +cached_at: datetime
    }

    class SynergyLookupRequest {
        +card_name: str
        +max_results: int
        +archetype: Optional[str]
        +format_filter: Optional[str]
    }

    class SynergyResult {
        +name: str
        +similarity_score: float
        +card_id: Optional[str]
    }

    class SynergyLookupResponse {
        +source_card: str
        +synergies: List[SynergyResult]
        +total_found: int
        +execution_time: float
        +top_synergies() List[SynergyResult]
    }

    MTGCard "1" *-- "many" CardColor
    MTGCard "1" *-- "many" CardType
    BaseAgent "1" *-- "1" AgentState
    BaseAgent "1" *-- "1" AgentType
    UserQuery "1" *-- "1" QueryIntent
    QueryIntent "1" *-- "1" QueryType
    ReasoningChain "1" *-- "many" ReasoningStep
    ReasoningStep "1" *-- "1" AgentType
    FusedResponse "1" *-- "many" AgentResponse
    DeckAnalysisResult "1" *-- "1" ManaCurveAnalysis
    DeckAnalysisResult "1" *-- "1" LandRatioAnalysis
    DeckAnalysisResult "1" *-- "many" SynergyDetection
    DeckAnalysisResult "1" *-- "1" WinConditionAnalysis
    DeckAnalysisResult "1" *-- "1" ArchetypeConsistency
    DeckAnalysisResult "1" *-- "1" DeckStrengths
    DeckAnalysisResult "1" *-- "1" DeckWeaknesses
    CardCollection "1" *-- "many" MTGCard
    SynergyLookupResponse "1" *-- "many" SynergyResult
    DatabaseService ..> CardORM : uses
    CardORM ..> MTGCard : converts to
    AgentOrchestratorV2 ..> UserQuery : processes
    AgentOrchestratorV2 ..> FusedResponse : produces

    %% ============================================================================
    %% CONFIGURATION
    %% ============================================================================
    class Settings {
        +app_name: str
        +version: str
        +debug: bool
        +default_model: str
        +scheduling_model: str
        +knowledge_model: str
        +symbolic_model: str
        +analyzer_model: str
        +mtgjson_path: str
        +preload_on_startup: bool
        +l1_max_size: int
        +l2_max_size: int
        +l3_max_size: int
        +host: str
        +port: int
        +openai_api_key: str
        +anthropic_api_key: str
    }

    %% ============================================================================
    %% NOTES
    %% ============================================================================
    note for IAgent "Interface Segregation:\nAll agents handle both dict (v1)\nand Pydantic request objects (v2)"
    note for ICardRepository "Repository Pattern:\nAbstracts data access\nwith cache + DB fallback"
    note for CardRepository "Two-tier lookup:\n1. ICache.set() (O(1) hot cards)\n2. DatabaseService (O(log n) full DB)"
    note for MultiTierCache "L1: Hot queries (Dict)\nL2: Warm queries (Dict)\nL3: Cold queries (Dict)\nAuto-promotion on access"
    note for DeckBuilderServiceV2 "Iterative deck building:\n1. Fetch candidate cards via repository\n2. Score cards by archetype\n3. Analyze with IAnalyzer (if available)\n4. Validate with IValidator (optional)\n5. Repeat up to max_iterations\nAnalyzer optional: None-safe implementation"
    note for PatternSynergyService "Pattern complementarity matching:\n1. Extract synergy patterns from oracle text\n2. Match mechanical patterns (trigger â†” payoff)\n3. Score by pattern complement strength\nReplaces semantic similarity approach"
    note for SynergyLookupService "Pattern-based synergy lookup:\n1. Resolve card name via CardRepository\n2. Query PatternSynergyService for patterns\n3. Apply optional format/archetype filters\n4. Return sorted results by synergy score\n5. Ignore card names, match mechanics"
    note for AgentOrchestratorV2 "End-to-end orchestration:\n1. Route by query type (classification)\n2. Delegate to specialized agents\n3. DeckBuilderServiceV2 for deck building\n4. Fuse results into FusedResponse\nDeck builder fully initialized and functional"
